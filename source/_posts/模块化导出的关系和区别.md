---
title: 模块化导出的关系和区别
date: 2020-06-15 23:34:11
tags:
  - 基础
categories:
  - 基础
---

## CommonJs

**Node**应用由模块组成，采用CommonJS模块规范。

根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。

CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。

```js
//a.js
const fn = () => {
	console.log(666)
}
module.exports = {fn}
//也可使用module.exports.fn = fn 或 exports.fn = fn ，两者效果相同
//exports = {fn} 这种写法不行，相当于重新给exports赋值，切断了与module.exports的联系
```

```js
//b.js
const moduleA = require('./a.js')
moduleA.fn()
```

为了方便，Node为每个模块提供一个exports变量，指向module.exports。其实我们真正执行暴露导出的是module.exports这个api。

这相当于在每个模块头部，有一行这样的命令：

```js
let exports = module.exports
```

于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。但是不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系，所有require就访问不到该文件使用exports暴露出来的对象方法	



## ES6

不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。 

```js
//a.js
const fn = () => {
	console.log(666)
}
export {fn}
//export fn
```

```js
//b.js
import moduleA from './a.js' //也可解构 import {fn} from './a.js'

moduleA.fn() //fn()
```

导出模块也可使用export default命令， 为模块指定默认输出。但每个文件只能有一个。可与export同时存在

```js
export default {
	fn(){
        console.log(666)
    }
}
//export default function(){console.log(666)}
```

