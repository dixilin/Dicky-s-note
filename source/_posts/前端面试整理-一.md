---
title: 前端面试整理(一)
date: 2020-05-14 19:42:12
categories: 
    - 面试
tags: 
    - 面试
---

## http

### http协议的主要特点：

简单快速、灵活、无连接、无状态



### http报文的组成部分

请求报文：请求行、请求头、空行、请求体

响应报文：状态行、响应头、空行、响应体



### 一次完整的http服务过程

**当我们在浏览器地址中输入了www.baidu.com，会发生什么?**

1.对www.baidu.com这个网址进行dns域名解析，得到对应的ip地址。

2.根据这个ip地址，找到对应的服务器，发起tcp的三次握手。

3.建立tcp连接后发起http请求（tcp是比http更底层的一个连接协议，ip是tcp下一层）。

4.服务器响应http请求

5浏览器解析html代码，并请求html代码中的资源（如js、css、图片等，先得到html代码才能去找这些资源）

6.浏览器对页面进行渲染呈现给用户

7.服务器关闭tcp连接

**注：**

**1.dns怎么找到域名？**

​	dns域名解析采用的是递归查询的方式，过程是先去找dns缓存->缓存找不到就去找根域名服务器->根域名又会去找下一级，这样递归查找之后查找到了返回给浏览器。

**2.http协议为什么要基于tcp实现？**

​	tcp是一个端到端的可靠的面向连接的协议，http基于传输层tcp协议不用担心数据传输的各种问题（当发生错误时会重新传输）



### tcp三次握手四次挥手大白话版

{%asset_img p1.png%}

#### 三次握手（建立连接）：

**第一次握手**：客户端要和服务端通信，先通知服务端，发出 SYN=1 的连接请求信号：“宝贝我想跟你说说话（SYN）”

**第二次握手**：服务端接收到客户端的连接请求，给客户端一个确认信息：“ 我知道了（ACK）,我这边已经准备好了，你现在能连吗（SYN）”

**第三次握手**：当客户端收到了服务端的确认连接信息后，要礼貌的告知一下服务端：“好的，咱们开始连线吧（ACK）” 



到此整个建立连接的过程已经结束，接下来就是双方你一句我一句甚至同时交流传递信息的过程了。 



#### 四次挥手（断开连接）：

**第一次挥手**：双方交流的差不多了，此时客户端也已经结尾了，接下来要断开通信连接，所以告诉服务端：“我说完了（FIN）”，此时自身形成等待结束连接的状态 。

**第二次挥手**：服务端知道客户端已经没话说了，服务端此时还有两句心里话要给客户端说，“我知道你说完了（ACK），我再给你说两句，&*……%￥”。

**第三次挥手**：此时客户端洗耳恭听继续处于等待结束的状态，服务器端也说完了，自身此时处于等待关闭连接的状态，并对告诉客户端，“我说完了，咱们断了吧（FIN）”。

**第四次挥手**：客户端收知道服务端也说完了，也要告诉服务端一声（ACK），因为连接和断开要双方都按下关闭操作才能断开，客户端同时又为自己定义一个定时器，因为不知道刚才说的这句话能不能准确到达服务端（网络不稳定或者其他因素引起的网络原因），默认时间定为两个通信的最大时间之和，超出这个时间就默认服务器端已经接收到了自己的确认信息，此时客户端就关闭自身连接，服务器端一旦接收到客户端发来的确定通知就立刻关闭服务器端的连接。

到此为止双方整个通信过程就此终结。这里要声明一下：断开链接不一定就是客户端，谁都可以先发起断开指令，另外客户端和服务端是没有固定标准的，谁先发起请求谁就是客户端。 

#### **问：**

**1.为什么断开链接的时候客户端设置的定时器时间等待要2MSL(两个通信报文的最大时间)？**
这个问题也很好理解，当客户端最终告诉服务器端断开确认的时候，他不知道自己的发出的指令是否能准确的一次性被服务器接收。假如服务器没有接收到（这已经耗费了一个报文的最大通信时间了），服务器端将会重新发起一个结束通话的指令（FIN）到客户端，客户端又接收到了服务器发来的结束通信指令将继续给服务器进行一个确认，有人会说那要是客户端发出的确认信息服务端没收到，而服务端重发的断开指令客户端也没收到怎么办，说实话我也无奈，遇到这种情况咱们干脆认为网确实不行了。

**2.为什么建立连接要三次握手而断开连接要四次挥手?**
说起这个，打一个比喻，目前祖国正在高速发展高铁，建立连接的过程正如上海到北京打通一条高铁线，TCP通信过程是一个全双工模式，即在这条高铁线上要有两个轨道，即能从上海发车到北京又能从北京发车到上海，甚至两边可以同时发车。所以断开连接前提就是要保证两条轨道都没有车，然后双方才能各自发起断开动作。



### 持久连接

http采用的是“请求-应答”模式，当使用普通模式，即非keep-alive时，每个请求、应答客户端和服务器都要新建立一个连接，完成之后立即断开连接。

当使用keep-alive时（持久连接，1.1版本支持），keep-alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，keep-alive避免建立或重新建立连接。



### 管线化

在使用持久连接的情况下，某个连接上消息的传递类似于

请求1->响应1->请求2->响应2->请求3->响应3

 

管线化使得连接上的消息变成了类似与

请求1->请求2->请求3->响应1->响应->响应3



管线化机制通过持久连接完成，仅http/1.1支持。只有get和head请求可以进行管线化，post有所限制。要求服务端支持管线化，但并不要求服务端对响应进行管线化处理，只要求对管线化的请求不失败即可。开启管线化并不会带来大幅度的性能提升，而且很多服务器和代理程序对管线化的支持并不好。因为现代浏览器如chrome和firefox默认并未开启管线化



## 创建对象的方法

```js
var o1 = new Object({name:'o1'})
// var o1 = {name:'o1'}
```



```js
function O2 (){
	this.name = 'o2'
}
var o2 = new O2()
```



```js
var o3 = Object.create({name:'o3'})
//name属性在o3.__proto__上
```



## 安全

### CSRF（依赖用户登录网站）

跨站请求伪造，英文名cross-site request forgery。

你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。

攻击原理：

​    1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

​    2. 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请     		求到网站A；

3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

       4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
       5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。  

防御：

 1. 验证http  Referer字段。根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址 

 2. 请求地址添加token， 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue"/> 

 3. 请求头中添加token，

    这里重点强调一下cookie的机制：**浏览器向一个域名发起http请求时会带上浏览器保存的关于那个域名的cookies，而不管你从哪个网站发请求** 。

    疑问：域名A被入侵，攻击者可以植入js代码，然后获取cookie构造头部，可以吗？

    答案是不行的，因为js要获取cookie存在3个因素限制：

    - Path。也就是URI的路径，路径不同，不允许访问
    - Doamin。域名不同不允许访问
    - http-only。设置为true之后，js不能访问

    很显然，**因为当前发起请求所在的域名和攻击者的目标域名不一样，所以即使页面被注入的js代码，也无法获取目标域名的cookie**。其次，对于存放`session_id`的cookie，一般都设置为`http-only`，禁止js读取，这也是防止xss攻击的主要手段。

    

### XSS

Cross Site Scripting，中文名为跨站脚本攻击 。是发生在**目标用户的浏览器**层面上的，当渲染DOM树的过程成发生了**不在预期内**执行的JS代码时，就发生了XSS攻击。 

#### xss类型

**反射型**： 发出请求时，XSS代码出现在URL中，作为输入提交到服务器，服务器解释后相应，在响应内容中出现这段XSS代码，最后由浏览器解释执行！ 

**存储型**:    

存储型XSS和反射型XSS的区别：
提交的XSS代码会存储在服务器上，下次请求目标页面的时候不需要再次提交XSS代码！！
存储的位置可以是数据库、内存、文件系统等。

典型的例子就是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些		留言的内容就会从数据库查询出来并显示，在浏览器上与正常的HTML和JS解析执行，触发XSS攻击！！ 

**DOM型**：

DOM XSS攻击不同于反射型XSS和存储型XSS，DOM XSS代码不需要服务器端的解析响应的直接参与，而是通过浏览器端的DOM解析。这完全是客户端的事情。 

DOM XSS代码的攻击发生的可能在于我们编写JS代码造成的。我们知道eval语句有一个作用是将一段字符串转换为真正的JS语句，因此在JS中使用eval是很危险的事情，容易造成XSS攻击。避免使用eval语句。

 如以下代码 

```
test.addEventListener('click', function () {
  var node = window.eval(txt.value)
  window.alert(node)
}, false)

txt中的代码如下
<img src='null' onerror='alert(123)' />
```

#### XSS危害

1. 通过document.cookie盗取cookie
2. 使用js或css破坏页面正常的结构与样式
3. 流量劫持（通过访问某段具有window.location.href定位到其他页面）
4. Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。
5. 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。
6. 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。

#### XSS防御

从以上的反射型和DOM XSS攻击可以看出，我们不能原样的将用户输入的数据直接存到服务器，需要对数据进行一些处理。以上的代码出现的一些问题如下

1. 没有过滤危险的DOM节点。如具有执行脚本能力的script, 具有显示广告和色情图片的img, 具有改变样式的link, style, 具有内嵌页面的iframe, frame等元素节点。
2. 没有过滤危险的属性节点。如事件, style, src, href等
3. 没有对cookie设置httpOnly。

如果将以上三点都在渲染过程中过滤，那么出现的XSS攻击的概率也就小很多。

解决方法如下:

**对cookie的保护**

1. 对重要的cookie设置httpOnly, 防止客户端通过`document.cookie`读取cookie。服务端可以设置此字段。

**对用户输入数据的处理**

1. 编码：不能对用户输入的内容都保持原样，对用户输入的数据进行字符实体编码。对于字符实体的概念可以参考文章底部给出的参考链接。
2. 解码：原样显示内容的时候必须解码，不然显示不到内容了。
3. 过滤：把输入的一些不合法的东西都过滤掉，从而保证安全性。如移除用户上传的DOM属性，如onerror，移除用户上传的Style节点，iframe, script节点等。

实现原理如下：

1. 存在一个parse函数，对输入的数据进行处理，返回处理之后的数据
2. 对输入的数据（如DOM节点）进行解码（使用第三方库 he.js）
3. 过滤掉一些元素有危害的元素节点与属性节点。如script标签，onerror事件等。（使用第三方库HTMLParser.js）

```
<script src='/javascripts/htmlparse.js'></script>
<script src='/javascripts/he.js'></script>
// 第三方库资源在文章底部给出

// parse函数实现如下

function parse (str) {
      // str假如为某个DOM字符串
      // 1. result为处理之后的DOM节点
      let result = ''
      // 2. 解码
      let decode = he.unescape(str, {
          strict: true
      })
      HTMLParser(decode, {
          start (tag, attrs, unary) {
              // 3. 过滤常见危险的标签
              if (tag === 'script' || tag === 'img' || tag === 'link' || tag === 'style' || tag === 'iframe' || tag === 'frame') return
              result += `<${tag}`
              for (let i = 0; i < attrs.length; i++) {
                  let name = (attrs[i].name).toLowerCase()
                  let value = attrs[i].escaped
                  // 3. 过滤掉危险的style属性和js事件
                  if (name === 'style' || name === 'href' || name === 'src' || ~name.indexOf('on')) continue
                  result += ` ${name}=${value}`
              }
              result += `${unary ? ' /' : ''} >`
          },
          chars (text) {
              result += text
          },
          comment (text) {
              result += `<!-- ${text} -->`
          },
          end (tag) {
              result += `</${tag}>`
          }
      })
      return result
  }
```

 因此，有了以上的parse函数之后，就可以避免大部分的xss攻击了。 

```
test.addEventListener('click', function () {
  // ... 省略部分代码
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
        // 3. 客户端解析JSON，并执行
        // test按钮的点击事件中唯一的变化就是使用parse对服务端返回的数据进行了解码和过滤的处理。
        var str = parse(JSON.parse(xhr.responseText).test)
        // 通过parse解析之后返回的数据就是安全的DOM字符串
        var node = `${str}`
        document.body.insertAdjacentHTML('beforeend', node)
      }
    }
  }
  // ... 省略部分代码
}, false)
```

## 浏览器运行机制

1.构建dom树（parse）：渲染引擎解析html文档，首先将html标签转成dom树中的dom node（包括js生成的标签）生成内容树（dom tree）

2.构建渲染树（construct）：解析对应的css样式文件（包括js生成的样式和外部css文件），而这些文件信息以及html中可见的指令构建渲染树（render tree）；render tree中每个dom node都会有自己的style，而且render tree不包含隐藏的节点（display:none以及head节点，原因是这些节点不会被渲染）。

3.布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点在屏幕上的精确坐标。

4.绘制渲染树（paint/repaint）：遍历渲染树，使用ui层来绘制每个节点。

## 重绘及回流

### 重绘（redraw/repaint）

当盒子的位置、大小以及其他属性，例如颜色、字体大小确定下来之后，浏览器便把这些属性都按照各自的特性绘制一编，将内容呈现在页面上。

#### 概念：

重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新特性重新绘制，使元素呈现新的外观

#### 触发重绘的条件：

改变元素外观属性，如：color、background-color..



### 回流/重排/重构/（reflow）

当渲染树的一部分因为元素的规模尺寸、布局，隐藏等改变而需要重新构建，这就称为回流（reflow）。每个页面至少需要回流一次，即页面第一次加载时。



### 重绘和回流的关系：

在回流的时候，浏览器会使渲染树中收到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。

所以，回流必定会引起重绘，但重绘不一定会引起回流。



### 触发回流的条件：

1.页面渲染初始化（无法避免）

2.添加或删除可见dom

3.元素位置的改变、使用动画

4.元素尺寸改变，大小、宽高、边距、边框

5.浏览器窗口变化（resize）

6.填充内容改变，比如文本改变或图片大小改变而引起重新计算宽高

7.读取某些元素属性，比如offsetLeft/offsetTop/offsetHeight/offsetWidth，clientLeft/clientTop/clientHeight/clientWidth，scrollTop/Left/Height/Width，width，height，getComputedStyle等等



### 优化

过多重绘及回流会导致浏览器卡顿以及加载时长增加。

1.尽可能少的操作dom

2.直接改变className而不是style

3.将需要进行多次重绘回流的元素脱离文档流，变化不会影响到其他元素。例如position:absolute或fixed

4.如需创建多个dom节点，可以创建fragment，将多个dom插入片段中，最后一次性的插入。（document.createDocumentFragment()  ）



## 装饰器（decorator）

es7语法，装饰器是一个函数，它可以给类或者属性方法加上一些其他东西，实现一些代码的复用

```js
function test(target){
    //target就是TestClass这个类
	target.flag = true
    console.log('调用了',target)
}

@test
class TestClass {
	
}

@test
class Person {
	
}
```

```js
function test(flag){
	return function(target){
		console.log(flag)
	}
}

@test(true)
class TestClass {
	
}

@test(false)
class Person {
	
}

```



可以在类之前用装饰器，也可在类里的属性和方法用

```js
function readonly(target,name,descriptor){
	//target为当前类，name为属性名，descriptor为描述对象
    /*
     *descriptor对象原来的值如下
    {
		configurable: false,//能否使用delete、能否修改属性特性，能否修改访问器属性，false为不能，默认为true
        enumrable: false, //是否可枚举，默认为true，是否可通过for...in循环获取属性
        writable: false, //默认为true，对象属性是否可修改
        value: '阿狗' //对象属性的默认值
    }
    */
    descriptor.wirtable = false //即设置属性不可修改
}

class Person {
    //给name属性加上readonly这个装饰器
    @readonly
    name='狗儿'
}

var p = new Person()
console.log(p.name)
p.name = '阿猫' //报错，原因是装饰器已经设置name属性不可修改

```



## 浏览器缓存

浏览器本身有缓存功能，有时候刷新代码没有生效，网站优化等等问题。

缓存：浏览器可能会把上一次的代码缓存起来，你再次访问就没有去拿最新的代码，而是拿的缓存代码

强缓存不发请求到服务器，直接拿缓存。协商缓存会发请求到服务器，询问服务器是拿缓存还是拿最新的代码。

### http缓存

浏览器缓存主要是http协议定义的缓存机制。HTML meta标签，例如

<META HTTP-EQUIV="Pragma" CONTENT="no-store">


含义是让浏览器不缓存当前页面。但是代理服务器不解析html内容，一般应用广泛的是http头信息控制缓存

#### 术语

缓存命中率：从缓存中得到数据的请求数与所有请求数的比例，立项状态是越高越好

过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用户回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然有效

验证：验证缓存中的内容是否仍然有效，验证通过的话刷新过期时间

失效：失效就是把内容从缓存中移除，当内容发生改变时就必须移除失效的内容



#### 缓存分类

浏览器缓存分为**强缓存**和**协商缓存**，浏览器加载一个页面的简单流程如下

1.浏览器先根据这个资源的http头信息来判断是否为强缓存，如果是强缓存则直接加载缓存中的资源，并不会发送请求到服务器（强缓存）

2.如果不是强缓存，则历览器会将资源加载请求发送到服务器。服务器判断浏览器本地缓存是否失效。若可以使用，则服务器不会返回资源信息，浏览器继续从缓存中加载资源（协商缓存）

3.如果也不是协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载服务器返回的新资源，并更新缓存



##### 强缓存

命中强缓存时候，浏览器并不会将请求发送给服务器。在Chrome开发者工具中看到状态码是200，并且后面会多一行from memory cache



**强缓存存在的意义**：服务器的资源是有限的，比如一台服务器只能承受5000的并发量，这时如果你设置了强缓存，就可能可以处理50000的并发。无需访问服务器直接从浏览器获取资源



强缓存是利用http的返回头中的Expires或者Cache-control两个字段控制的，用来表示资源的缓存时间

###### Expires

缓存过期时间（绝对时间），用来指定资源到期的时间，是服务端的具体时间，需要和Last-modified结合使用。由于失效时间是一个绝对时间，所以客户端本地时间被修改后，服务器与客户端时间偏差变大，会导致缓存混乱。于是发展出了Cache-control

###### Cache-control

缓存过期时间（相对时间，优先级高于Expires）。例如Cache-control:3600，代表资源有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。

Cache-control可以由多个字段组合而成,max-age、s-maxage、public、private、no-chche、no-store等

例如：**max-age**：Cache-control:max-age:31536000



##### 协商缓存

若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息的中的Last-Modify/If-Modify-Since或ETag/If-None-Match来判断是否命中协商缓存。如果命中，则http状态码返回304，浏览器从缓存中加载资源。



###### **Last-Modify/If-Modify-Since**

在浏览器第一次请求一个资源的时候，服务器响应头会加上Last-Modify，Last-Modify是一个时间标识，该资源的最后修改时间，例如：Last-Modify：Fri，14 May 2020 17:22:22 GMT

当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源最后修改时间判断是否命中协商缓存

如果命中缓存，则返回304，不会返回资源内容，也不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一样），于是出现了ETag/If-None-Match



###### ETag/If-None-Match

与Last-Modify/If-Modify-Since不同的是，ETag/If-None-Match返回的是一个效验码：Etag: entity tag。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。Etag值的变更说明资源状态已经被修改。服务器根据浏览器上发送的请求头的If-None-Match值来判断是否命中缓存





## h5离线存储 manifest

查看： 在application cache里可以看见

使用：

1.html标签增加manifest="cache.manifest"

```
<html manifest="cache.manifest">

```

2.根目录创建cache.manifest文件

```
CACHE MANIFEST
#V0.11 

CACHE:
js/common.js
css/style.cssf

NETWORK:
resourse/logo.png

FALLBACK:
/ ./404.html

```

离线存储的manifest一般由三个部分组成：

CACHE：表示需要离线存储的资源列表，由于包含manifest文件的页面将自动被离线存储，所以不需要把页面自身列出来

NETWORK：表示在它下面列出来的资源只有在线情况才能访问，即不会被离线缓存。CACHE优先级高于NETWORK

FALLBACK：表示如果访问第一个资源失败，就使用第二个资源代替。比如上面这个文件表示就是如果根目录下任何一个资源失败了，就去访问404.html



## fetch

一个底层的api，是XMLHttpRequest的最新替代技术，符合w3c标准。

语法简介，更加语义化，基于promise，脱离xhr，是es规范里新的实现方式。

缺点：

1.只对网络请求报错，对400、500都当作成功的请求，服务器返回400、500时错误码并不会reject，只有网络错误才会执行reject

2.不支持超时控制

3.没有办法监测请求进度（希望上传大文件能看到进度条），而xhr可以

```js
fetch('localhost:3000/test').then((res)=>{
    return res.json()
}).then((json)=>{
    console.log(json)
})

```



## 多页面通讯

### localStorage

页面1将数据存入localStorage，页面2监听事件window.addEventListener('storage',(e)=>{console.log(e)})，页面2也可使用setInterval轮询不停访问localStorage。

### cookie

页面1将数据存入cookie，页面2使用setInterval轮询

### websocket

具体事例自行百度，需服务端配合

### sharedWorker

worker是html5的新特性，用于实现js多线程。

普通的webworker直接使用new Worker()创建，这种webworker是当前页面专有的。

共享worker(sharedWorker)，这种是可以多个页面、多个iframe共同使用的。

sharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的。

具体实例自行百度