---
title: 前端面试基础二
date: 2020-06-15 23:33:39
tags:
  - 基础 
  - 面试
categories:
  - 基础
  - 面试
---

## 执行上下文

执行上下文就是代码的执行环境，英文execute context， 简称EC

js代码正式执行之前会先进入到执行环境。

**进入执行环境后做了哪些工作？**

1.创建变量对象（变量提升）

​		变量

​		函数及函数的参数

​		全局：window

​		局部：抽象的，但确实存在

2.确认this的指向

​		全局：this -> window

​		局部：this -> 调用其的对象

3.创建作用域链

​		父级及父级往上的作用域链 + 当前的变量对象



执行上下文，可认为是一个对象，叫做ECObj，执行上下文对象指的是this

```js
ECObj = {
   '变量对象': {'变量','函数','函数的形参'},
   scopeChain:'父级及父级往上的作用域链 + 当前的变量对象',
   this: {window,'调用其的对象'}
}
```



## 防抖和节流

### 节流

一个函数执行一次后，只有大于设定的执行周期后才会执行第二次

有个需要频繁触发的函数，出于性能优化，在规定时间内，只让函数触发一次。

```js
/*
 * 节流 
 * @param: fn 使用到节流的函数
 * @param: delay 延迟时间
 */
const throttle = (fn,delay) => {
	let lastTime = Date.now()
    return () => {
        let nowTime = Date.now()
        if(nowTime - lastTime > delay){
        	fn()
            last = Date,now()
    	}
    }
    
    
}
```



### 防抖

一个需要频繁触发的函数，在规定时间，只能最后一次生效

```js
/*
 * 防抖 
 * @param: fn 使用到防抖的函数
 * @param: delay 延迟时间
 */
const debounce = (fn,delay) => {
    let timer = null
    return ()=>{
        clearTimeout(timer)
        timer = setTimeout(()=>{
        	fn()
    	},delay)
    }
}
```



## 实现(5).add(3).minus(2)，输出结果

```js
(function(){
    function checkNum (n){
        if(typeof n !== 'number'){
            alert('只允许输入number类型')
        }
    }
	function add (n){
        return this + n
    }   
    function minus (n){
        return this - n
    }
    
    ['minus','add'].forEach((item)=>{
        Number.prototype[item] = eval(item)
    })
})()
```



## 深浅拷贝

### 浅拷贝

```js
let obj = {
    a: 100,
    b: [1,2,3],
    c: {
        x:'y'
    }
}

//1.
let copyObj1 = {...obj}

//2.
let copyObj2 = {}
for(let k in obj){
    //判断是否自身属性
    if(!obj.hasOwnProperty(key)) break
    copyObj2[k] = obj[k]
}
```



### 深拷贝

```js
let obj = {
    a: 100,
    b: [1,2,3],
    c: {
        x:'y'
    },
    d: function(){
        console.log(666)
    }
}

//1. 除了 函数和正则以及new Date()无法克隆，其余都可	
let copyObj1 = JSON.parse(JSON.stringify(obj))

//2.
function deepClone (obj) {
    if(obj === undefined){
    	return undefined
    }
    if(obj === null){
    	return null
    }
    if(typeof obj !== 'object'){
        return obj
    }
    if(obj instanceof RegExp){
    	return new RegExp(obj)
    }
    if(obj instanceof Date){
    	return new Date(obj)
    }
    //不直接创建空对象，克隆结果和之前保持相同的所属类
	let newObj = new obj.constructor
    for(let k in obj){
        //判断是否自身属性
        if(obj.hasOwnProperty(k)){
			console.log(newObj[k])
           	newObj[k] = deepClone(obj[k])
        }
    }
    return newObj
}
```
